# Backend Schema Usage in IoT Device

## Database Schema Integration

The IoT device correctly implements communication with your backend using the schema defined in `documents/SCHEMA_REFERENCE.md`.

### Device Registration (devices table)

**Schema Fields Used:**
```
- id (auto-generated by backend)
- userId (from mobile app during provisioning)
- serialNumber (unique device identifier)
- name (device name)
- type (device type: MUSHROOM_CHAMBER)
- status (ONLINE, OFFLINE, ERROR, MAINTENANCE)
- location (physical location)
- firmware (firmware version)
- ipAddress (local IP address)
- macAddress (network MAC address)
- lastSeen (last communication timestamp)
- isActive (activation status)
```

**Implementation:** `src/backend_client.py` - `register_device()`
```python
payload = {
    'userId': user_id,
    'serialNumber': self.device_id,
    'name': device_info.get('name'),
    'type': device_info.get('type', 'MUSHROOM_CHAMBER'),
    'location': device_info.get('location'),
    'firmware': device_info.get('firmware'),
    'ipAddress': device_info.get('ip_address'),
    'macAddress': device_info.get('mac_address'),
    'status': 'ONLINE',
    'isActive': True
}

POST /api/devices
```

---

### Sensor Data (sensor_data table)

**Schema Fields Used:**
```
- id (auto-generated)
- deviceId (backend device ID)
- sensorId (sensor identifier)
- userId (device owner)
- type (sensor type: environment, co2, temperature, humidity)
- value (sensor reading value)
- unit (measurement unit: ppm, celsius, percent)
- quality (reading quality indicator)
- timestamp (reading timestamp)
```

**Implementation:** `src/backend_client.py` - `send_sensor_data()`
```python
payload = {
    'deviceId': backend_device_id,
    'sensorId': sensor_data.get('sensor_id'),
    'userId': self.registration_data.get('userId'),
    'type': sensor_data.get('type', 'environment'),
    'value': sensor_data.get('value', 0),
    'unit': sensor_data.get('unit', 'mixed'),
    'quality': sensor_data.get('quality'),
    'timestamp': sensor_data.get('timestamp')
}

POST /api/sensor-data
```

**Batch Upload:**
```python
POST /api/sensor-data/batch
{
  "readings": [
    { deviceId, userId, type, value, unit, timestamp },
    ...
  ]
}
```

---

### Device Commands (device_commands table)

**Schema Fields Used:**
```
- id (auto-generated)
- deviceId (target device)
- command (command name: actuator_control, sensor_config, etc.)
- parameters (command parameters as JSON)
- status (pending, completed, failed)
- response (command response data)
- sentAt (command sent timestamp)
- acknowledgedAt (command acknowledgment timestamp)
```

**Implementation:** `src/backend_client.py`

**Fetch Pending Commands:**
```python
GET /api/device-commands/device/{deviceId}/pending

Response: [
  {
    id, deviceId, command, parameters, status, sentAt
  }
]
```

**Acknowledge Command:**
```python
PATCH /api/device-commands/{commandId}
{
  "status": "completed",
  "response": { result data },
  "acknowledgedAt": "2025-11-06T02:00:00Z"
}
```

**Mobile App Creates Command:**
```python
POST /api/device-commands
{
  "deviceId": "backend-device-id",
  "command": "actuator_control",
  "parameters": {
    "action": "set",
    "led_lights": true
  }
}
```

---

### Device Health (device_health table)

**Schema Fields Used:**
```
- id (auto-generated)
- deviceId (device identifier)
- timestamp (health check timestamp)
- status (HEALTHY, WARNING, CRITICAL)
- cpuUsage (CPU usage percentage)
- memoryUsage (memory usage percentage)
- diskUsage (disk usage percentage)
- temperature (device temperature)
- batteryLevel (battery level if applicable)
- networkLatency (network latency in ms)
- uptime (device uptime in seconds)
- errorCount (error count)
- metadata (additional metadata as JSON)
```

**Implementation:** `src/backend_client.py` - `send_health_data()`
```python
payload = {
    'deviceId': backend_device_id,
    'status': health_data.get('status', 'HEALTHY'),
    'cpuUsage': health_data.get('cpu_usage'),
    'memoryUsage': health_data.get('memory_usage'),
    'diskUsage': health_data.get('disk_usage'),
    'temperature': health_data.get('temperature'),
    'networkLatency': health_data.get('network_latency'),
    'uptime': health_data.get('uptime'),
    'errorCount': health_data.get('error_count', 0),
    'metadata': health_data.get('metadata'),
    'timestamp': datetime.now().isoformat()
}

POST /api/device-health
```

---

### Sensor Alerts (sensor_alerts table)

**Schema Fields (Not Yet Implemented):**
```
- id
- deviceId
- sensorId
- type (threshold, anomaly, failure)
- severity (low, medium, high, critical)
- title
- message
- threshold
- isActive
- isResolved
- resolvedAt
```

**Future Implementation:** Alerts will be generated by backend based on sensor data thresholds.

---

## Data Flow Examples

### 1. Device Registration Flow
```
IoT Device Boot
    ↓
Connect to WiFi
    ↓
POST /api/devices (with userId from mobile app)
    ↓
Backend creates device record
    ↓
Returns: { id: "uuid", serialNumber: "MASH-...", status: "ONLINE" }
    ↓
Device stores registration_data
    ↓
Ready for normal operation
```

### 2. Sensor Data Collection Flow
```
Arduino reads SCD41 sensor
    ↓
Serial → Raspberry Pi
    ↓
SensorManager processes reading
    ↓
Store in local SQLite database
    ↓
Every 5 minutes: batch sync to backend
    ↓
POST /api/sensor-data/batch
    ↓
Backend stores in sensor_data table
    ↓
Mobile app can query historical data
```

### 3. Cloud Actuator Control Flow
```
Mobile App (different network)
    ↓
POST /api/device-commands
{
  deviceId: "xxx",
  command: "actuator_control",
  parameters: { action: "set", led_lights: true }
}
    ↓
Backend creates device_command (status: pending)
    ↓
IoT Device polls: GET /api/device-commands/device/{id}/pending
    ↓
Device receives command
    ↓
ActuatorManager executes command
    ↓
Device acknowledges: PATCH /api/device-commands/{id}
{
  status: "completed",
  response: { success: true, state: {...} },
  acknowledgedAt: "timestamp"
}
    ↓
Mobile app sees updated status
```

---

## API Endpoint Summary

### Device Endpoints
- `POST /api/devices` - Register new device
- `PATCH /api/devices/serial/{serialNumber}` - Update device by serial
- `GET /api/devices/{id}` - Get device details
- `GET /api/devices/user/{userId}` - List user's devices

### Sensor Data Endpoints
- `POST /api/sensor-data` - Send single reading
- `POST /api/sensor-data/batch` - Send multiple readings
- `GET /api/sensor-data/device/{deviceId}` - Get device sensor history

### Device Command Endpoints
- `POST /api/device-commands` - Create command (from mobile)
- `GET /api/device-commands/device/{deviceId}/pending` - Get pending commands (from device)
- `PATCH /api/device-commands/{id}` - Acknowledge command (from device)

### Device Health Endpoints
- `POST /api/device-health` - Report health metrics
- `GET /api/device-health/device/{deviceId}` - Get device health history

---

## Configuration Requirements

### Environment Variables (.env)
```bash
# Required for backend communication
BACKEND_API_URL=https://mash-backend-api-production.up.railway.app/api
BACKEND_API_KEY=your_device_api_key
DEVICE_OWNER_USER_ID=user_uuid_from_mobile_app
```

### Mobile App Requirements

The mobile app must:
1. Provide `userId` during device provisioning
2. Create device commands for cloud control
3. Poll or subscribe to device status updates
4. Handle local API calls when on same network

---

## Authentication

### Device Authentication
- Uses Bearer token in Authorization header
- API key from `.env` file or backend registration
- Required for all backend API calls

### Mobile App Authentication
- Uses user JWT token
- Obtained from user login
- Required for creating commands and viewing device data

---

## Notes

1. **Device ID vs Backend ID:**
   - Device uses `serialNumber` as unique identifier
   - Backend assigns UUID `id` upon registration
   - Both are stored in `registration_data`

2. **User Association:**
   - Device must know `userId` for registration
   - Mobile app provides this during provisioning
   - Stored in `.env` as `DEVICE_OWNER_USER_ID`

3. **Offline Operation:**
   - Device stores data locally in SQLite
   - Syncs to backend when online
   - Can operate without backend for local control

4. **Real-time vs Polling:**
   - Current implementation uses polling (every N seconds)
   - Future: WebSocket for instant cloud commands
   - Local control is always real-time (direct HTTP)
